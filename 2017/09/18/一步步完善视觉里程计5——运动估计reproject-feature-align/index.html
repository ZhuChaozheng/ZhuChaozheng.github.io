<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>一步步完善视觉里程计5——运动估计reproject,feature align | BlackAnt</title>
  
    <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  <meta name="author" content="ZhuChaozheng SunTong ChuZhefan">
  
  <meta name="description" content="This website is designed by x-space, and use to offer a professional robot solutions.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="一步步完善视觉里程计5——运动估计reproject,feature align"/>
  <meta property="og:site_name" content="BlackAnt"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="BlackAnt" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?77ef4451b3a9c64e7da624afdd20490e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">BlackAnt</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/new-page">Blog</a></li>
    
      <li><a href="/about">about</a></li>
    
	<li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-09-18T14:29:14.000Z"><a href="/2017/09/18/一步步完善视觉里程计5——运动估计reproject-feature-align/">2017-09-18</a></time>
      
      
  
    <h1 class="title">一步步完善视觉里程计5——运动估计reproject,feature align</h1>
  

    </header>
    <div class="entry">
      
        <p><strong>通过前一篇博客我们目前可以计算出3d点和相机pose，但是我们根据之前阐述知道通过两帧的计算结果是不精确，会出现漂移的现象。这一篇文章考虑有共同视角的多个关键帧，具体示意图如下：</strong><a id="more"></a></p>
<p><img src="http://7xl6tk.com1.z0.glb.clouddn.com/feature_align.png"></p>
<p>也就是不仅仅考虑相连的两帧的，而是考虑前面所有有相同视角的关键帧，通过多帧来进行约束。</p>
<h2 id="reproject">reproject</h2>
<p>我们很容易想到是通过前面计算的3D点的投影到当前帧，看是否可以投影来判断，这个时候我们就要考虑3D点的存储。对于SLAM问题我们考虑构建map，在map中存储3D点和关键帧，提供根据当前帧寻找有共同视野的关键帧，具体定义如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Map : public Noncopyable</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">Map();</div><div class="line">~Map();</div><div class="line"></div><div class="line">/// 得到跟目前帧有重叠视野的所有关键帧</div><div class="line">void getCloseKeyframes(const FramePtr&amp; frame, std::list&lt; std::pair&lt;FramePtr, double&gt; &gt;&amp; close_kfs) const;</div><div class="line"></div><div class="line">public:</div><div class="line">std::list&lt; FramePtr &gt; keyframes_;        //!&lt; 地图中存储的所有关键帧</div><div class="line">std::list&lt; Point3D* &gt;   points_;         //!&lt; 存放3D点</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>获得有重叠视野的关键帧，就根据当前帧的特征对应的3D点，是否能投影到其它关键帧中，可以则这个关键帧与当前帧有相关视野，但是我们并不希望计算所有的特征，我们在关键帧上选取5个特征作为帧上的关键特征。<br> 在Frame类中添加关键特征，如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">std::vector&lt;Feature*&gt; key_pts_; //!&lt;使用5个特征，用于检测两帧之间是否有重叠的视野</div></pre></td></tr></table></figure></p>
<p>这些点用于快速检测是否两个帧有重叠的视野，选取5个特征，一个在图像中点另外4个靠近图像的4个边角，并且这5个特征都要有对应的3D点,具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Frame::setKeyPoints()</div><div class="line">&#123;</div><div class="line">// 如果特征指向的3d点为空，则设置该特征为NULL</div><div class="line">for (size_t i = 0; i &lt; 5; ++i)</div><div class="line">if (key_pts_[i] != NULL)</div><div class="line">if (key_pts_[i]-&gt;point == NULL)</div><div class="line">key_pts_[i] = NULL;</div><div class="line">// 找到5个特征</div><div class="line">std::for_each(fts_.begin(), fts_.end(), [&amp;](Feature* ftr)&#123; if (ftr-&gt;point != NULL) checkKeyPoints(ftr); &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体5个关键特征点如何选择，如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">void Frame::checkKeyPoints(Feature* ftr)</div><div class="line">&#123;</div><div class="line">// 首先得到相机中心点</div><div class="line">const int cu = cam_-&gt;width() / 2;</div><div class="line">const int cv = cam_-&gt;height() / 2;</div><div class="line"></div><div class="line">// 如果第一个特征为空，则进入的第一个特征转为关键特征，如果不为空，则判断新进入的特征是否比之前特征</div><div class="line">// 更接近中心，是，则替换该特征</div><div class="line">if (key_pts_[0] == NULL)</div><div class="line">key_pts_[0] = ftr;</div><div class="line">else if (std::max(std::fabs(ftr-&gt;px[0] - cu), std::fabs(ftr-&gt;px[1] - cv))</div><div class="line">&lt; std::max(std::fabs(key_pts_[0]-&gt;px[0] - cu), std::fabs(key_pts_[0]-&gt;px[1] - cv)))</div><div class="line">key_pts_[0] = ftr;</div><div class="line">// 找到中间的特征之后，将图片分成4块，在每块中找出1个特征，离中心越远的特征</div><div class="line">if (ftr-&gt;px[0] &gt;= cu &amp;&amp; ftr-&gt;px[1] &gt;= cv)</div><div class="line">&#123;</div><div class="line">if (key_pts_[1] == NULL)</div><div class="line">key_pts_[1] = ftr;</div><div class="line">else if ((ftr-&gt;px[0] - cu) * (ftr-&gt;px[1] - cv)</div><div class="line">&gt; (key_pts_[1]-&gt;px[0] - cu) * (key_pts_[1]-&gt;px[1] - cv))</div><div class="line">key_pts_[1] = ftr;</div><div class="line">&#125;</div><div class="line">if (ftr-&gt;px[0] &gt;= cu &amp;&amp; ftr-&gt;px[1] &lt; cv)</div><div class="line">&#123;</div><div class="line">if (key_pts_[2] == NULL)</div><div class="line">key_pts_[2] = ftr;</div><div class="line">else if ((ftr-&gt;px[0] - cu) * (ftr-&gt;px[1] - cv)</div><div class="line">&gt; (key_pts_[2]-&gt;px[0] - cu) * (key_pts_[2]-&gt;px[1] - cv))</div><div class="line">key_pts_[2] = ftr;</div><div class="line">&#125;</div><div class="line">if (ftr-&gt;px[0] &lt; cu &amp;&amp; ftr-&gt;px[1] &lt; cv)</div><div class="line">&#123;</div><div class="line">if (key_pts_[3] == NULL)</div><div class="line">key_pts_[3] = ftr;</div><div class="line">else if ((ftr-&gt;px[0] - cu) * (ftr-&gt;px[1] - cv)</div><div class="line">&gt; (key_pts_[3]-&gt;px[0] - cu) * (key_pts_[3]-&gt;px[1] - cv))</div><div class="line">key_pts_[3] = ftr;</div><div class="line">&#125;</div><div class="line">if (ftr-&gt;px[0] &lt; cu &amp;&amp; ftr-&gt;px[1] &gt;= cv)</div><div class="line">&#123;</div><div class="line">if (key_pts_[4] == NULL)</div><div class="line">key_pts_[4] = ftr;</div><div class="line">else if ((ftr-&gt;px[0] - cu) * (ftr-&gt;px[1] - cv)</div><div class="line">&gt; (key_pts_[4]-&gt;px[0] - cu) * (key_pts_[4]-&gt;px[1] - cv))</div><div class="line">key_pts_[4] = ftr;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后这边要注意的是如果特征点删除了，其可能对于关键特征点，这个关键特征点也必须要移除，因此我们添加如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void Frame::removeKeyPoint(Feature* ftr)</div><div class="line">&#123;</div><div class="line">bool found = false;</div><div class="line">std::for_each(key_pts_.begin(), key_pts_.end(), [&amp;](Feature*&amp; i)&#123;</div><div class="line">if (i == ftr) &#123;</div><div class="line">i = NULL;</div><div class="line">found = true;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">if (found)</div><div class="line">setKeyPoints();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们在Map类中添加根据当前帧获得具体相关视野的关键帧，具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/// 获得有重叠视野的关键帧，就根据当前帧的特征对应的3D点，是否能投影到其它关键帧中，可以则</div><div class="line">/// 这个关键帧与当前帧有相关视野</div><div class="line">void Map::getCloseKeyframes(</div><div class="line">const FramePtr&amp; frame,</div><div class="line">std::list&lt; std::pair&lt;FramePtr, double&gt; &gt;&amp; close_kfs) const</div><div class="line">&#123;</div><div class="line">for (auto kf : keyframes_)</div><div class="line">&#123;</div><div class="line">// 检测当前帧与关键帧之间是否有重叠的视野，通过关键点(特征)来进行计算</div><div class="line">for (auto keypoint : kf-&gt;key_pts_)</div><div class="line">&#123;</div><div class="line">if (keypoint == nullptr)</div><div class="line">continue;</div><div class="line"></div><div class="line">if (frame-&gt;isVisible(keypoint-&gt;point-&gt;pos_))// 判断目前帧的特征所对应的3d点是否在关键帧中可见</div><div class="line">&#123;</div><div class="line">close_kfs.push_back(std::make_pair(</div><div class="line">kf, (frame-&gt;T_f_w_.translation() - kf-&gt;T_f_w_.translation()).norm()));</div><div class="line">break; // 这个关键帧跟目前帧有重叠的视野，则加入close_kfs</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找到了有共同视野的关键帧之后，我们要对其它有共同视野的关键帧上的特征点对应的3D点投影到当前帧上，但是为了很好的效率，我们不对所有的点进行投影匹配，只在一个单元格子中匹配一个点，这样，我们可以对所有的匹配特征进行均匀分布，而且不用投影所有的点这样可以更好的节约时间。<br> 具体定义一个Grid如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Reprojector</div><div class="line">&#123;</div><div class="line">/// candidate是一个点投影到图片平面，我们在图像中找到了与该点匹配的特征</div><div class="line">struct Candidate &#123;</div><div class="line">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</div><div class="line">Point* pt;       //!&lt; 3D点</div><div class="line">Vector2d px;     //!&lt; 投影的2D像素点</div><div class="line">Candidate(Point* pt, Vector2d&amp; px) : pt(pt), px(px) &#123;&#125;</div><div class="line">&#125;;</div><div class="line">typedef std::list&lt;Candidate, aligned_allocator&lt;Candidate&gt; &gt; Cell;</div><div class="line">typedef std::vector&lt;Cell*&gt; CandidateGrid;</div><div class="line"></div><div class="line">/// grid用于存储一系列候选匹配.对于每一个grid单元格努力寻找一个匹配</div><div class="line">struct Grid</div><div class="line">&#123;</div><div class="line">CandidateGrid cells;//!&lt; 用于存放3D点和对应的投影2D像素坐标列表</div><div class="line">std::vector&lt;int&gt; cell_order;//!&lt; 单元格的顺序编号</div><div class="line">int cell_size;//!&lt; 单应格的大小</div><div class="line">int grid_n_cols;//!&lt; 图像划分单元格的列数</div><div class="line">int grid_n_rows;//!&lt; 图像划分单元格的行数</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Grid grid_;//!&lt; 图像划分为网格</div><div class="line"></div><div class="line">///  初始化Grid</div><div class="line">void initializeGrid(AbstractCamera* cam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先对Grid进行初始化，具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void Reprojector::initializeGrid(AbstractCamera* cam)</div><div class="line">&#123;</div><div class="line">grid_.cell_size = Config::gridSize();</div><div class="line">grid_.grid_n_cols = ceil(static_cast&lt;double&gt;(cam-&gt;width()) / grid_.cell_size);</div><div class="line">grid_.grid_n_rows = ceil(static_cast&lt;double&gt;(cam-&gt;height()) / grid_.cell_size);</div><div class="line">grid_.cells.resize(grid_.grid_n_cols*grid_.grid_n_rows);</div><div class="line">// 初始化单元格，在析构中删除</div><div class="line">std::for_each(grid_.cells.begin(), grid_.cells.end(), [&amp;](Cell*&amp; c)&#123; c = new Cell; &#125;);</div><div class="line">grid_.cell_order.resize(grid_.cells.size());</div><div class="line">for (size_t i = 0; i &lt; grid_.cells.size(); ++i)</div><div class="line">grid_.cell_order[i] = i;</div><div class="line">std::random_shuffle(grid_.cell_order.begin(), grid_.cell_order.end()); // 随机排列，一种策略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样Grid划分好了之后，那下面就开始重投影，具体是找到与当前帧有相关视野最靠近的N个关键帧 ，这边设置N的最大值为10，靠近的N个关键帧的个数不超过10个。遍历这N个关键帧，对每个关键帧观察到的点投影到当前帧中，记录这每个关键帧与当前帧共同的观察点的个数。具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void Reprojector::reprojectMap(</div><div class="line">FramePtr frame,</div><div class="line">std::vector&lt; std::pair&lt;FramePtr, std::size_t&gt; &gt;&amp; overlap_kfs)</div><div class="line">&#123;</div><div class="line">resetGrid();</div><div class="line"></div><div class="line">// 选出与目前帧有重叠视野的关键帧</div><div class="line">std::list&lt; std::pair&lt;FramePtr, double&gt; &gt; close_kfs;</div><div class="line">map_.getCloseKeyframes(frame, close_kfs);</div><div class="line"></div><div class="line">// 对靠近的关键帧根据靠近程度进行排序</div><div class="line">close_kfs.sort(compareDistance);</div><div class="line"></div><div class="line">// 对有有重叠部分的N个关键帧对应的mappoints进行重投影，我们只存储格子中特征点减少的</div><div class="line">size_t n = 0;</div><div class="line">overlap_kfs.reserve(options_.max_n_kfs);</div><div class="line">// 对最近的N个关键帧进行迭代，找到有重叠视野</div><div class="line">for (auto it_frame = close_kfs.begin(), ite_frame = close_kfs.end();</div><div class="line">it_frame != ite_frame &amp;&amp; n &lt; options_.max_n_kfs; ++it_frame, ++n)</div><div class="line">&#123;</div><div class="line">FramePtr ref_frame = it_frame-&gt;first;</div><div class="line">overlap_kfs.push_back(std::pair&lt;FramePtr, size_t&gt;(ref_frame, 0));</div><div class="line"></div><div class="line">// 对这个参考帧观察到的点投影到当前帧中</div><div class="line">for (auto it_ftr = ref_frame-&gt;fts_.begin(), ite_ftr = ref_frame-&gt;fts_.end();</div><div class="line">it_ftr != ite_ftr; ++it_ftr)</div><div class="line">&#123;</div><div class="line">// 检测这个特征是否有分配的mappoint</div><div class="line">if ((*it_ftr)-&gt;point == NULL)</div><div class="line">continue;</div><div class="line"></div><div class="line">// 确保我们只投影一次，不同帧上的特征会对应同一个3D点</div><div class="line">if ((*it_ftr)-&gt;point-&gt;last_projected_kf_id_ == frame-&gt;id_)</div><div class="line">continue;</div><div class="line">(*it_ftr)-&gt;point-&gt;last_projected_kf_id_ = frame-&gt;id_;</div><div class="line">if (reprojectPoint(frame, (*it_ftr)-&gt;point))</div><div class="line">overlap_kfs.back().second++;//相同观察点的数目</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="feature-align">feature align</h2>
<p>根据下图，我们知道特征的投影会存在偏差，这样我们就需要进行feature align</p>
<p><img src="http://7xl6tk.com1.z0.glb.clouddn.com/feature_align.png"></p>
<p>在上一个过程中，将图像划分为了格子，则在这个一个格子的同一个特征可能会存在偏差，即同一个格子中会出现多个近似真实帧的特征及其对应3D点。feature align的工作即对同一个格子中的相似特征进行优化。<br> 具体做法：通过投影的特征与当前特征进行对比。<br> 首先根据当前帧的位置得到最近帧对应的特征，具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bool Point3D::getCloseViewObs(const Vector3d&amp; framepos, Feature*&amp; ftr) const</div><div class="line">&#123;</div><div class="line">// TODO: 后期要确保点是相同的视图和相同的金字塔层</div><div class="line">// 得到观察的方向向量</div><div class="line">Vector3d obs_dir(framepos - pos_);</div><div class="line">obs_dir.normalize();</div><div class="line">auto min_it = obs_.begin();</div><div class="line">double min_cos_angle = 0;</div><div class="line">for (auto it = obs_.begin(), ite = obs_.end(); it != ite; ++it)</div><div class="line">&#123;</div><div class="line">Vector3d dir((*it)-&gt;frame-&gt;pos() - pos_);</div><div class="line">dir.normalize();</div><div class="line">double cos_angle = obs_dir.dot(dir);// 单位向量点乘得到cos角度</div><div class="line">if (cos_angle &gt; min_cos_angle)//保证特征是距离较近的两个帧</div><div class="line">&#123;</div><div class="line">min_cos_angle = cos_angle;</div><div class="line">min_it = it;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">ftr = *min_it;</div><div class="line">if (min_cos_angle &lt; 0.5) // 假设观察夹角大于60度没有用</div><div class="line">return false;</div><div class="line">return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再计算两帧之间的仿射变换。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void Matcher::getWarpMatrixAffine(</div><div class="line">const AbstractCamera&amp; cam_ref,</div><div class="line">const AbstractCamera&amp; cam_cur,</div><div class="line">const Vector2d&amp; px_ref,</div><div class="line">const Vector3d&amp; f_ref,</div><div class="line">const double depth_ref,</div><div class="line">const SE3&amp; T_cur_ref,</div><div class="line">const int level_ref,</div><div class="line">Matrix2d&amp; A_cur_ref)</div><div class="line">&#123;</div><div class="line">// 计算仿射变换矩阵A_ref_cur</div><div class="line">const int halfpatch_size = 5;</div><div class="line">const Vector3d xyz_ref(f_ref*depth_ref);</div><div class="line">Vector3d xyz_du_ref(cam_ref.cam2world(px_ref + Vector2d(halfpatch_size, 0)*(1 &lt;&lt; level_ref)));</div><div class="line">Vector3d xyz_dv_ref(cam_ref.cam2world(px_ref + Vector2d(0, halfpatch_size)*(1 &lt;&lt; level_ref)));</div><div class="line">xyz_du_ref *= xyz_ref[2] / xyz_du_ref[2];</div><div class="line">xyz_dv_ref *= xyz_ref[2] / xyz_dv_ref[2];</div><div class="line">const Vector2d px_cur(cam_cur.world2cam(T_cur_ref*(xyz_ref)));</div><div class="line">const Vector2d px_du(cam_cur.world2cam(T_cur_ref*(xyz_du_ref)));</div><div class="line">const Vector2d px_dv(cam_cur.world2cam(T_cur_ref*(xyz_dv_ref)));</div><div class="line">A_cur_ref.col(0) = (px_du - px_cur) / halfpatch_size;</div><div class="line">A_cur_ref.col(1) = (px_dv - px_cur) / halfpatch_size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>具体上述仿射变换的求解应该只求解了旋转变换，具体还不是很理解为什么这么计算.</strong><br> 两帧之间的仿射变换计算好了之后，计算当前帧面片在另外一帧所处的金字塔等级，具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int Matcher::getBestSearchLevel(const Matrix2d&amp; A_cur_ref, const int max_level)</div><div class="line">&#123;</div><div class="line">// 计算在其它图像中面片所处金字塔等级</div><div class="line">int search_level = 0;</div><div class="line">double D = A_cur_ref.determinant();</div><div class="line">while (D &gt; 3.0 &amp;&amp; search_level &lt; max_level)</div><div class="line">&#123;</div><div class="line">search_level += 1;</div><div class="line">D *= 0.25;</div><div class="line">&#125;</div><div class="line">return search_level;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>这边为什么通过仿射变换计算行列式可以寻找合适的尺度，也不是很理解</strong><br> 下一步就是对面片应用仿射变换 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void Matcher::warpAffine(</div><div class="line">const Matrix2d&amp; A_cur_ref,</div><div class="line">const cv::Mat&amp; img_ref,</div><div class="line">const Vector2d&amp; px_ref,</div><div class="line">const int level_ref,</div><div class="line">const int search_level,</div><div class="line">const int halfpatch_size,</div><div class="line">uint8_t* patch)</div><div class="line">&#123;</div><div class="line">const int patch_size = halfpatch_size * 2;</div><div class="line">const Matrix2f A_ref_cur = A_cur_ref.inverse().cast&lt;float&gt;();</div><div class="line">if (isnan(A_ref_cur(0, 0)))</div><div class="line">&#123;</div><div class="line">printf(&quot;Affine warp is NaN, probably camera has no translation\n&quot;); // TODO</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对面片执行warp操作</div><div class="line">uint8_t* patch_ptr = patch;</div><div class="line">const Vector2f px_ref_pyr = px_ref.cast&lt;float&gt;() / (1 &lt;&lt; level_ref);</div><div class="line">for (int y = 0; y &lt; patch_size; ++y)</div><div class="line">&#123;</div><div class="line">for (int x = 0; x &lt; patch_size; ++x, ++patch_ptr)</div><div class="line">&#123;</div><div class="line">Vector2f px_patch(x - halfpatch_size, y - halfpatch_size);</div><div class="line">px_patch *= (1 &lt;&lt; search_level);</div><div class="line">const Vector2f px(A_ref_cur*px_patch + px_ref_pyr);// 进行仿射变换</div><div class="line">if (px[0] &lt; 0 || px[1] &lt; 0 || px[0] &gt;= img_ref.cols - 1 || px[1] &gt;= img_ref.rows - 1)</div><div class="line">*patch_ptr = 0;</div><div class="line">else</div><div class="line">*patch_ptr = (uint8_t)interpolateMat_8u(img_ref, px[0], px[1]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>这边对上一帧的特征进行仿射变换计算新的对应特征，这边两帧之间的仿射变换的逆变换乘以标准面片加上上一帧的特征，这也不是很理解</strong><br> 注意上面的面片计算，都是采用了带有边框的面片，即面片大小是88，而实际计算是1010，这样可以保证面片的每个像素都被计算，这样，这一步就是通过带边框的面片计算面片，具体如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Matcher::createPatchFromPatchWithBorder()</div><div class="line">&#123;</div><div class="line">uint8_t* ref_patch_ptr = patch_;</div><div class="line">for (int y = 1; y &lt; patch_size_ + 1; ++y, ref_patch_ptr += patch_size_)</div><div class="line">&#123;</div><div class="line">uint8_t* ref_patch_border_ptr = patch_with_border_ + y*(patch_size_ + 2) + 1;</div><div class="line">for (int x = 0; x &lt; patch_size_; ++x)</div><div class="line">ref_patch_ptr[x] = ref_patch_border_ptr[x];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后就是feature align 特征优化，残差就是当前图像可能特征与投影特征的差值。<br> 具体代码如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">bool align2D(</div><div class="line">const cv::Mat&amp; cur_img,</div><div class="line">uint8_t* ref_patch_with_border,</div><div class="line">uint8_t* ref_patch,</div><div class="line">const int n_iter,</div><div class="line">Vector2d&amp; cur_px_estimate,</div><div class="line">bool no_simd)</div><div class="line">&#123;</div><div class="line">const int halfpatch_size_ = 4;</div><div class="line">const int patch_size_ = 8;</div><div class="line">const int patch_area_ = 64;</div><div class="line">bool converged = false;</div><div class="line"></div><div class="line">#ifdef _MSC_VER</div><div class="line">__declspec(align(16)) float ref_patch_dx[patch_area_];</div><div class="line">__declspec(align(16)) float ref_patch_dy[patch_area_];</div><div class="line">#else</div><div class="line">float __attribute__((__aligned__(16))) ref_patch_dx[patch_area_];</div><div class="line">float __attribute__((__aligned__(16))) ref_patch_dy[patch_area_];</div><div class="line">#endif</div><div class="line">Matrix3f H; H.setZero();</div><div class="line"></div><div class="line">// 计算梯度和hessian</div><div class="line">const int ref_step = patch_size_ + 2;</div><div class="line">float *it_dx = ref_patch_dx;</div><div class="line">float *it_dy = ref_patch_dy;</div><div class="line">for (int y = 0; y &lt; patch_size_; ++y)</div><div class="line">&#123;</div><div class="line">uint8_t* it = ref_patch_with_border + (y + 1)*ref_step + 1;</div><div class="line">for (int x = 0; x &lt; patch_size_; ++x, ++it, ++it_dx, ++it_dy)</div><div class="line">&#123;</div><div class="line">Vector3f J;</div><div class="line">J[0] = 0.5 * (it[1] - it[-1]);//x方向梯度值</div><div class="line">J[1] = 0.5 * (it[ref_step] - it[-ref_step]);//y方向梯度值</div><div class="line">J[2] = 1;</div><div class="line">*it_dx = J[0];</div><div class="line">*it_dy = J[1];</div><div class="line">H += J*J.transpose();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Matrix3f Hinv = H.inverse();</div><div class="line">float mean_diff = 0;</div><div class="line"></div><div class="line">// 计算在新图像中的像素位置</div><div class="line">float u = cur_px_estimate.x();</div><div class="line">float v = cur_px_estimate.y();</div><div class="line"></div><div class="line">// 终止条件</div><div class="line">const float min_update_squared = 0.03*0.03;</div><div class="line">const int cur_step = cur_img.step.p[0];</div><div class="line">Vector3f update;</div><div class="line">update.setZero();</div><div class="line">for (int iter = 0; iter &lt; n_iter; ++iter)</div><div class="line">&#123;</div><div class="line">int u_r = floor(u);</div><div class="line">int v_r = floor(v);</div><div class="line">if (u_r &lt; halfpatch_size_ || v_r &lt; halfpatch_size_ || u_r &gt;= cur_img.cols - halfpatch_size_ || v_r &gt;= cur_img.rows - halfpatch_size_)</div><div class="line">break;</div><div class="line">// TODO very rarely this can happen, maybe H is singular? should not be at corner.. check</div><div class="line">if (isnan(u) || isnan(v))</div><div class="line">return false;</div><div class="line"></div><div class="line">// 计算插值权重</div><div class="line">float subpix_x = u - u_r;</div><div class="line">float subpix_y = v - v_r;</div><div class="line">float wTL = (1.0 - subpix_x)*(1.0 - subpix_y);</div><div class="line">float wTR = subpix_x * (1.0 - subpix_y);</div><div class="line">float wBL = (1.0 - subpix_x)*subpix_y;</div><div class="line">float wBR = subpix_x * subpix_y;</div><div class="line"></div><div class="line">// 循环遍历 插值</div><div class="line">uint8_t* it_ref = ref_patch;</div><div class="line">float* it_ref_dx = ref_patch_dx;</div><div class="line">float* it_ref_dy = ref_patch_dy;</div><div class="line"></div><div class="line">Vector3f Jres; Jres.setZero();</div><div class="line">for (int y = 0; y &lt; patch_size_; ++y)</div><div class="line">&#123;</div><div class="line">uint8_t* it = (uint8_t*)cur_img.data + (v_r + y - halfpatch_size_)*cur_step + u_r - halfpatch_size_;</div><div class="line">for (int x = 0; x &lt; patch_size_; ++x, ++it, ++it_ref, ++it_ref_dx, ++it_ref_dy)</div><div class="line">&#123;</div><div class="line">float search_pixel = wTL*it[0] + wTR*it[1] + wBL*it[cur_step] + wBR*it[cur_step + 1];</div><div class="line">float res = search_pixel - *it_ref + mean_diff;</div><div class="line">Jres[0] -= res*(*it_ref_dx);</div><div class="line">Jres[1] -= res*(*it_ref_dy);</div><div class="line">Jres[2] -= res;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">update = Hinv * Jres;//负号前面已经添加</div><div class="line">u += update[0];</div><div class="line">v += update[1];</div><div class="line">mean_diff += update[2];</div><div class="line"></div><div class="line">if (update[0] * update[0] + update[1] * update[1] &lt; min_update_squared)</div><div class="line">&#123;</div><div class="line">converged = true;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">cur_px_estimate &lt;&lt; u, v;</div><div class="line">return converged;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>具体高斯牛顿求解还是有欠缺</strong><br> 到这里整个重投影及feature align就结束了，最后记录好匹配上的跟踪特征数，对这个数设好上下限。<br> 写了简单的测试程序如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">CmdLine cmd;</div><div class="line">std::string first_frame_name;</div><div class="line">std::string second_frame_name;</div><div class="line">std::string third_frame_name;</div><div class="line"></div><div class="line">cmd.add(make_option(&apos;f&apos;, first_frame_name, &quot;firstname&quot;));</div><div class="line">cmd.add(make_option(&apos;s&apos;, second_frame_name, &quot;secondname&quot;));</div><div class="line">cmd.add(make_option(&apos;t&apos;, third_frame_name, &quot;thirdname&quot;));</div><div class="line">try &#123;</div><div class="line">if (argc == 1) throw std::string(&quot;Invalid command line parameter.&quot;);</div><div class="line">cmd.process(argc, argv);</div><div class="line">&#125;</div><div class="line">catch (const std::string&amp; s) &#123;</div><div class="line">std::cerr &lt;&lt; &quot;Feature detector \nUsage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot;\n&quot;</div><div class="line">&lt;&lt; &quot;[-f|--firstname name]\n&quot;</div><div class="line">&lt;&lt; &quot;[-s|--secondname name]\n&quot;</div><div class="line">&lt;&lt; &quot;[-t|--thirdname name]\n&quot;</div><div class="line">&lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cerr &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">return EXIT_FAILURE;</div><div class="line">&#125;</div><div class="line">cv::Mat first_img(cv::imread(first_frame_name, 0));</div><div class="line">cv::Mat second_img(cv::imread(second_frame_name, 0));</div><div class="line">cv::Mat third_img(cv::imread(third_frame_name, 0));</div><div class="line">assert(first_img.type() == CV_8UC1 &amp;&amp; !first_img.empty());</div><div class="line">assert(second_img.type() == CV_8UC1 &amp;&amp; !second_img.empty());</div><div class="line">assert(third_img.type() == CV_8UC1 &amp;&amp; !third_img.empty());</div><div class="line"></div><div class="line">AbstractCamera* cam = new PinholeCamera(752, 480, 315.5, 315.5, 376.0, 240.0);</div><div class="line"></div><div class="line">FramePtr fisrt_frame(new Frame(cam, first_img, 0.0));</div><div class="line">FramePtr second_frame(new Frame(cam, second_img, 1.0));</div><div class="line">FramePtr third_frame(new Frame(cam, third_img, 1.0));</div><div class="line"></div><div class="line">Initialization init;</div><div class="line">init.addFirstFrame(fisrt_frame);</div><div class="line">init.addSecondFrame(second_frame);</div><div class="line"></div><div class="line">SparseImgAlign img_align(4, 1,</div><div class="line">30, SparseImgAlign::GaussNewton, false, false);</div><div class="line">size_t img_align_n_tracked = img_align.run(second_frame, third_frame);</div><div class="line">std::cout &lt;&lt; &quot;Img Align:\t Tracked = &quot; &lt;&lt; img_align_n_tracked &lt;&lt; std::endl;</div><div class="line">mvo::Map map;</div><div class="line">fisrt_frame-&gt;setKeyframe();</div><div class="line">second_frame-&gt;setKeyframe();</div><div class="line">map.addKeyframe(fisrt_frame);</div><div class="line">map.addKeyframe(second_frame);</div><div class="line">Reprojector reprojector(cam,map);</div><div class="line">std::vector&lt; std::pair&lt;FramePtr, size_t&gt; &gt; overlap_kfs;</div><div class="line">reprojector.reprojectMap(third_frame, overlap_kfs);</div><div class="line">const size_t repr_n_new_references = reprojector.n_matches_;</div><div class="line">const size_t repr_n_mps = reprojector.n_trials_;</div><div class="line">std::cout &lt;&lt; &quot;Reprojection:\t nPoints = &quot; &lt;&lt; repr_n_mps &lt;&lt; &quot;\t \t nMatches = &quot; &lt;&lt; repr_n_new_references&lt;&lt;std::endl;</div><div class="line">getchar();</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后结果如下：</p>
<p><img src="http://7xl6tk.com1.z0.glb.clouddn.com/feature_align_project.png"></p>
<h2 id="总结">总结</h2>
<p>运动估计总共分成了三块，image align ，feature align以及接下来的pose and structure refinement.主要的都是优化，解决的问题基本都是非线性最小二乘问题，确定好合适的残差，求解的过程。对于非线性最小二乘的实现这个基础要好好掌握。</p>
<p>转载自冯兵的博客，<a href="http://fengbing.net/2015/09/06/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A15%E2%80%94%E2%80%94%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1reprojector,feature%20align/" target="_blank" rel="external">原文链接</a></p>

      
    </div>
    <footer>
      
        
        
        <div class="bdsharebuttonbox">
		<a href="#" class="bds_more" data-cmd="more"></a>
		<a href="#" class="bds_qzone" data-cmd="qzone"></a>
		<a href="#" class="bds_tsina" data-cmd="tsina"></a>
		<a href="#" class="bds_tqq" data-cmd="tqq"></a>
		<a href="#" class="bds_renren" data-cmd="renren">
		</a><a href="#" class="bds_weixin" data-cmd="weixin"></a>
		</div>
<script>
window._bd_share_config={
"common":{
"bdSnsKey":{},
"bdText":"",
"bdMini":"2",
"bdPic":"",
"bdStyle":"0",
"bdSize":"16"},
"share":{},
"image":{
"viewList":[
"qzone","tsina",
"tqq","renren",
"weixin"],
"viewText":"分享到：",
"viewSize":"16"},
"selectShare":{
"bdContainerClass":null,
"bdSelectMiniList":[
"qzone","tsina","tqq",
"renren","weixin"]
}
};
with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<!-- 页面导航 -->
 <nav id="pagination" >
    
    <a href="/2017/09/18/一步步完善视觉里程计6——运动估计Pose-and-Structure-Refinement/" class="alignleft prev" >Prev</a>
    
    
    <a href="/2017/09/18/一步步完善视觉里程计4——运动估计image-align/" class="alignright next" >Next</a>
    
    <div class="clearfix"></div>
</nav>
<section id="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-category="<#article/category/id#>" data-thread-key="<#article/id#>" data-title="<#article/title#>" data-author-key="<#article/author/id#>"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"aichimantou"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:blog.blackant.org">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/robot/Java/Android/">Android</a><small>1</small></li>
  
    <li><a href="/categories/robot/Java/">Java</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/categories/robot/">robot</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/SAE/" style="font-size: 10px;">SAE</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/directions/" style="font-size: 10px;">directions</a> <a href="/tags/donation/" style="font-size: 10px;">donation</a> <a href="/tags/goal/" style="font-size: 20px;">goal</a> <a href="/tags/hello/" style="font-size: 10px;">hello</a> <a href="/tags/helloworld/" style="font-size: 10px;">helloworld</a> <a href="/tags/robot/" style="font-size: 10px;">robot</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">Link</h3>
<ul class="entry">
<li><a href="http://baidu.com/" title="Baidu Corportion">iRobot</a></li>
<li><a href="http://baidu.com/" title="Baidu Corportion">Rocket</a></li>
<li><a href="http://baidu.com/" title="Baidu Corportion">FFmpeg</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 ZhuChaozheng SunTong ChuZhefan
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>